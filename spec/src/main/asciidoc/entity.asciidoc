// Copyright (c) 2022,2025 Contributors to the Eclipse Foundation
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0

== Entity Classes

The notion of an _entity_ is the fundamental building block with which a data model may be constructed.
Abstractly, an entity (or _entity type_) is a schema for data.

- The schema may be as simple as a tuple of types, as is typical in the relational model, or it might be structured, as in document data stores.
- The schema might be explicit, as in the case of SQL DDL declaring a relational table, or it might be implicit, as is commonplace in key/value stores.
- Either way, we assume that the entity is represented in Java as a class, which we call the _entity class_. footnote:[We will not consider generic programs which work with entity data via detyped representations.]

NOTE: When there's no risk of confusion, we often use the word “entity” to mean the entity class, or even an instance of the entity class.

Data represented by an entity is persistent, that is, the data itself outlives any Java process which makes use of it. Thus, it is necessary to maintain an association between instances of Java entity classes and state held in a data store.

- Each persistent instantiation of the schema is distinguishable by a unique _identifier_. For example, a row of a relational database table is identifiable by the value of its primary key.
- Any persistent instantiation of the schema is representable by an instance of the entity class. In a given Java program, multiple entity class instances might represent the same persistent instance of the schema.

In Jakarta Data, the concrete definition of an entity may be understood to encompass the following aspects:

1. The *entity class* itself: An entity class is simple Java object equipped with fields or accessor methods designating each attribute of the entity. An entity class is identified by an annotation.

2. Its *data schema*: Some data storage technologies require an explicit schema defining the structure and properties of the data the entity represents. For example, a relational database requires that the schema be specified using SQL Data Definition Language (DDL) statements. The schema might be generated by the Jakarta Data provider, from the information available in the Java entity class, or it might be managed independently. When the data store itself does not require an explicit schema, the data schema is implicit.

3. Its *association with a repository*: Each entity class is associated with at least one repository, which exposes operations for retrieving and storing instances of the entity.

NOTE: A Jakarta Data provider might allow the state of a single Jakarta Data entity to be stored across multiple entities in the data store. For example, in Jakarta Persistence, the `@SecondaryTable` annotation allows the state of an entity to be mapped across more than one database table.

=== Programming Model for Entity Classes

A _programming model for entity classes_ specifies:

- a set of restrictions on the implementation of a Java class which allows it to be used as an entity class with a given Jakarta Data provider, and
- a set of annotations allowing the identification of a Java class as an entity class, and further specification of the schema of the entity.

Jakarta Data does not define its own programming model for entities, but instead:

- is compatible with the programming models defined by the Jakarta Persistence footnote:[Jakarta Persistence 3.2, https://jakarta.ee/specifications/persistence/3.2/] and Jakarta NoSQL footnote:[Jakarta NoSQL 1.0, https://jakarta.ee/specifications/nosql/1.0/] specifications, and
- allows for vendor-specific entity programming models to be defined by Jakarta Data providers.

This section lays out the core requirements that an entity programming model must satisfy in order to be compatible with Jakarta Data, and for the defining provider to be considered a fully-compliant implementation of this specification.

Every entity programming model specifies an _entity-defining annotation_. For Jakarta Persistence, this is `jakarta.persistence.Entity`. For Jakarta NoSQL, it is `jakarta.nosql.Entity`. A Jakarta Data provider must provide repository implementations for entity classes bearing the entity-defining annotations it supports, and must ignore entity classes with entity-defining annotations it does not support.

NOTE: To maintain clarity and to disambiguate the desired Jakarta Data provider, a single entity class should not mix entity-defining annotations from different providers. For example, an entity class should not be annotated both `jakarta.persistence.Entity` and `jakarta.nosql.Entity`. This practice allows the entity-defining annotation to indicate the desired provider in programs where multiple Jakarta Data providers are available.

Furthermore, an entity programming model must define an annotation which identifies the attribute holding the unique identifier of an entity. For Jakarta Persistence, it is `jakarta.persistence.Id` or `jakarta.persistence.EmbeddedId`. For Jakarta NoSQL, it is `jakarta.nosql.Id`. Alternatively, an entity programming model might allow the identifier attribute to be identified via some convention.

Typically, an entity programming model specifies additional annotations which are used to make the schema of the entity explicit, for example, `jakarta.persistence.Id` and `jakarta.persistence.Column`, or `jakarta.nosql.Id` and `jakarta.nosql.Column`. The nature of such annotations is beyond the scope of this specification.

In a given entity programming model, entity classes might always be mutable, or might always be immutable, or, alternatively, the model might support a mix of mutable and immutable entity classes.

- A programming model which supports immutable entity classes may require that every mutable entity class declare a constructor with no parameters, and might place limits on the visibility of this constructor.
- A programming model which supports the use of immutable entity classes--ideally represented as Java `record` types--would not typically require the existence of such a constructor.

In either case, an entity programming model might place restrictions on the visibility of fields and property accessors of an entity class.

==== Entity Inheritance

An entity programming model might support inheritance between entities.
Two entities are related by inheritance if:

1. the entity classes are related by Java language inheritance, and
2. the Jakarta Data provider supports retrieving and querying the entities in a polymorphic fashion.

It's possible for two entity classes to be related by Java inheritance, but _not_ by entity inheritance in the sense defined here.
An entity programming model specifies which Java inheritance relationships are interpreted as entity inheritance.

When entities are related by inheritance, a query method which returns the entity supertype might also return instances of its subtypes.

The Jakarta Data provider determines how entity classes which participate in an entity inheritance hierarchy "map" to the data schema.
For example, in a relational datastore, all entities in the hierarchy might be stored together on one table, or each entity might have its own dedicated table.

Support for entity inheritance is not required by this specification.

==== Persistent Attributes

An attribute of an entity class may or may not represent state which is persistent in the datastore.
A _persistent attribute_ has some corresponding representation in the data schema of the entity, for example, it might map to a column or columns in a relational database table.
Any programming model for entity classes must provide well-defined rules for distinguishing attributes which are persistent in the datastore from attributes which are _transient_, having no persistent representation in the datastore.
Furthermore, the programming model must specify how the Jakarta Data provider accesses the persistent attributes of an entity to read and write their values.

Every programming model for entity classes must support _direct field access_, that is, access to the persistent fields of an entity class without triggering any intermediating user-written code such as JavaBeans-style property accessors.
When direct field access is used, every Java field marked with the Java language `transient` modifier must be treated as transient.
A programming model might place constraints on the visibility of persistent fields.
For example, Jakarta Persistence disallows `public` persistent fields.
Every programming model must permit `private` persistent fields.

A programming model for entity classes might also support _property-based access_, that is, access to persistent attributes via JavaBeans-style property accessors, or, especially for Java `record` types, via accessor methods combined with constructor-based initialization.
Such programming models should provide an annotation or other convention to distinguish transient properties.
For example, Jakarta Persistence provides `jakarta.persistence.Transient`.
When property-based access is supported, a programming model might place constraints on the visibility of property accessors.
For example, Jakarta Persistence requires that property accessors be `public` or `protected`.
Support for property-based access is not required by this specification.

Jakarta Data distinguishes three kinds of persistent attributes within entity classes.

- A _basic attribute_ holds a value belonging to some fundamental data type supported natively by the Jakarta Data Provider. Support for the set of basic types enumerated in the next section below is mandatory for all Jakarta Data providers.
- An _embedded fattribute_ allows the inclusion of the state of a finer-grained Java class within the state of an entity. The type of an embedded attribute is often a user-written Java class. Support for embedded attributes varies depending on the Jakarta Data provider and the database type.
- An _association attribute_ implements an association between entity types. Support for association attributes varies depending on the Jakarta Data provider and the database type.

==== Basic Types

Every Jakarta Data provider must support the following basic types within its programming model:

|===
| Basic Data Type | Description

| Primitive types and wrapper classes
| All Java primitive types, such as `int`, `double`, `boolean`, etc., and their corresponding wrapper types from `java.lang` (e.g., `Integer`, `Double`, `Boolean`).

| `java.lang.String`
| Represents text data.

| `LocalDate`, `LocalDateTime`, `LocalTime`, `Instant` from `java.time`
| Represent date and time-related data.

| `java.util.UUID`
| Universally Unique IDentifier for identifying entities.

| `BigInteger` and `BigDecimal` from `java.math`
| Represent large integer and decimal numbers.

| `byte[]`
| Represents binary data.

| User-defined `enum` types
| Custom enumerated types defined by user-written code.
|===

NOTE: In this specification, "string" means `java.lang.String`, "numeric" means any primitive numeric type, wrapper for a primitive numeric type, `BigInteger`, or `BigDecimal`, and "date/time" means `LocalDate`, `LocalDateTime`, `LocalTime`, or `Instant`.

For example, the following entity class has five basic attributes:

[source,java]
----
@Entity
public class Person {
    @Id
    private UUID id;
    private String name;
    private long ssn;
    private LocalDate birthdate;
    private byte[] photo;
}
----

In addition to the types listed above, an entity programming model might support additional domain-specific basic types. This extended set of basic types might include types with a nontrivial internal structure. An entity programming model might even provide mechanisms to convert between user-written types and natively-supported basic types. For example, Jakarta Persistence defines the `AttributeConverter` interface.

NOTE: Many key-value, wide-column, document, and relational databases feature native support for arrays or even associative arrays of these basic types. Unfortunately, the semantics of such types--along with their performance characteristics--are extremely nonuniform, and so support for such types is left undefined by the Jakarta Data specification.

==== Embedded Attributes and Embeddable Classes

An _embeddable class_ differs from an entity class in that:

- the embeddable class lacks its own persistent identity, and
- the state of an instance of the embeddable class can only be stored in the database when the instance is referenced directly or indirectly by a "parent" entity class instance.

An _embedded attribute_ is an attribute whose type is an embeddable class.

Like entities, embeddable classes may have basic attributes, embeddable attributes, and association attributes, but, unlike entities, they do not have identifier attributes.

Like entities, a programming model for entity classes might support mutable embeddable classes, immutable embeddable classes, or both.

A programming model for entity classes might define an annotation that identifies a user-written class as an embeddable class. For example, Jakarta Persistence defines the annotation `jakarta.persistence.Embeddabe`. Alternatively, the programming model might define an annotation that identifies an attribute as an embedded attribute. For example, Jakarta Persistence defines the annotation `jakarta.persistence.Embedded`.

There are two natural ways that a Jakarta Data provider might store the state of an instance of an embedded class in a database:

- by _flattening_ the attributes of the embeddable class into the data structure representing the parent entity, or
- by _grouping_ the attributes of the embedded class into a fine-grained structured type (a UDT, for example).

In a flattened representation of an embedded attribute, the attributes of the embeddable class occur directly alongside the basic attributes of the entity class in the data schema of the entity.
There is no representation of the embeddable class itself in the data schema.

For example, consider the following Java classes:

[source,java]
----
@Embeddable
public class Address {
    private String street;
    private String city;
    private String postalCode;
}

@Entity
public class Person {
    @Id
    private Long id;
    private String name;
    private Address address;  // embedded attribute
}
----

In a document, wide-column, or graph database, the JSON representation of an instance of the `Person` entity might be as follows:

[source,json]
----
{
  "id": 1,
  "name": "John Doe",
  "street": "123 Main St",
  "city": "Sampleville",
  "postalCode": "12345"
}
----

Or, in a relational database, the DDL for the `Person` table might look like this:

[source,sql]
----
create table Person (
    id bigint primary key,
    name varchar,
    street varchar,
    city varchar,
    postalCode varchar
)
----

In a structured representation, the attributes of the embeddable class are somehow grouped together in the data schema.

For example, the JSON representation of `Person` might be:

[source,json]
----
{
  "id": 1,
  "name": "John Doe",
  "address":
  {
    "street": "123 Main St",
    "city": "Sampleville",
    "postalCode": "12345"
  }
}
----

Or the SQL DDL could be:

[source,sql]
----
create type Address as (
    street varchar,
    city varchar,
    postalCode varchar
)

create table Person (
    id bigint primary key,
    name varchar,
    address Address
)
----

NOTE: Support for embeddable classes and embedded attributes is not required by this specification.
However, every Jakarta Data provider is strongly encouraged to provide support for embeddable classes within its entity programming model.

==== Entity Associations

An association attribute is an attribute of an entity class whose declared type is also an entity class.
Given an instance of the first entity class, its association attribute holds a reference to an instance of a second entity class.

For example, consider the following Java classes:

[source,java]
----
@Entity
public class Author {
    @Id
    private UUID id;
    private String name;
    private List<Book> books;
}

@Entity
public class Book {
    @Id
    private Long id;
    private String title;
    private String category;
    private List<Author> authors;
}
----

In a relational database, these entities might map to the following data schema:

[source,sql]
----
create table Author (
    uuid id primary key,
    name varchar,
)

create table BookAuthor(
    book bigint,
    author uuid,
    primary key (book, author),
    foreign key (author) references Author,
    foreign key (book) references Book
)

create table Book (
    id bigint primary key,
    title varchar,
    category varchar
)
----

NOTE: Support for entity associations is not required by this specification.

=== Entity Names and Persistent Attribute Names

Entities and their persistent attributes may be referenced by name in the query language defined in <<Jakarta Data Query Language>>.

==== Entity Names

Each entity must be assigned an _entity name_ by the provider.
By default, this must be the unqualified Java class name of the entity class.
A programming model for entity classes might provide a way to explicitly specify an entity name.
For example, Jakarta Persistence allows the entity name to be specified via the `name` member of the `@Entity` annotation.

==== Persistent Attribute Names

Each persistent attribute of an entity, as defined above in <<Persistent Attributes>>, or of an embeddable class, as defined in <<Embedded Attributes and Embeddable Classes>>, must be assigned a name, allowing the persistent attribute to be referenced by an <<Parameter-based automatic query methods,automatic query method>>, a Query by Method Name, or from a query specified within the <<Annotated Query methods,`@Query` annotation>>.

- when direct field access is used, the name of a persistent attribute is simply the name of the Java field, but
- when property-based access is used, the name of the attribute is derived from the accessor methods.

Any programming model for entity classes which supports property-based access must also define a rule for assigning names to persistent attributes. Typically, a property with accessors named `getX` and `setX` is assigned a persistent attribute name obtained by calling `java.beans.Introspector.decapitalize("X")`.

Within a given entity class or embeddable class, names assigned to persistent attributes must be unique ignoring case. A Jakarta Data provider is permitted to reject an entity class if two persistent attributes would be assigned the same name.

Furthermore, within the context of a given entity, each persistent attribute of an embeddable class reachable by navigation from the entity class may be assigned a compound name. The compound name is obtained by concatenating the names assigned to each attribute traversed by navigation from the entity class to the persistent attribute of the embedded class, optionally joined by a delimiter.

The rule for concatenating compound names depends on the context, and is specified in <<attribute-name-concatenation>>. The examples in the table assume an `Order` entity has an `address` of type `MailingAddress` with a `zipCode` of type `int`.

[[attribute-name-concatenation]]
.Attribute Name Concatenation and Delimiters
[cols="3, 2, ^1, 6"]
|===
| Context | Type | Delimiter | Example

| `@Find` | Parameter name
|`_`
|`@Find List<Person> find(int address_zipCode);`

|`@Query` | Path expression within query
|`.`
|`@Query("FROM Person WHERE address.zipCode = ?1")`

|_Query by Method Name_ | Method name
|`_`
|`List<Person> findByAddress_zipCode(int zip);`

|`Sort` | String argument
|`.` or `_`
|`Sort.asc("address_zipCode")`

|`@By` or `@OrderBy` | Annotation value
|`.` or `_`
|`@Find List<Person> find(@By("address.zipCode") int zip);`
|===

NOTE: Application programmers are strongly encouraged to follow Java's camel case naming standard for attributes of entities, relations, and embeddable classes, avoiding underscores in attribute names. The resolution algorithm for persistent attribute identification relies on the use of underscore as a delimiter. Adhering to the camel case naming convention ensures consistency and eliminates ambiguity.



=== Type-safe Access to Entity Attributes

Jakarta Data provides a static metamodel that allows entity attributes to be accessed by applications in a type-safe manner.

For each entity class, the application developer or a compile-time annotation processor can define a corresponding metamodel class following a prescribed set of conventions.

- The metamodel class can be an interface or concrete class.
- The metamodel class must be annotated with `@StaticMetamodel`, specifying the entity class as its `value`.
- The metamodel class contains one or more `public static` fields corresponding to persistent attributes of the entity class.
- The type of each of these attributes must be either `java.lang.String`, `jakarta.data.metamodel.Attribute`, or a subinterface of `Attribute` from the package `jakarta.data.metamodel`.

The application can use the field values of the metamodel class to obtain artifacts relating to the entity attribute in a type-safe manner, for example, `_Book.title.asc()` or `Sort.asc(_Book.title.name())` or `Sort.asc(_Book.TITLE)` rather than `Sort.asc("title")`.

==== Application Requirements for a Metamodel Class

When an application programmer writes a static metamodel class for an entity by hand:

- each field corresponding to a persistent attribute of an entity must have modifiers `public`, `static`, and `final` (these are implicit when the metamodel class is an interface), and
- the fields must be statically initialized.

The static metamodel class is not required to include a field for every persistent attribute of the entity.

A convenience implementation of each subinterface of `Attribute` is provided in the package `jakarta.data.metamodel.impl`.

==== Compile-time Annotation Processor Requirements for a Metamodel Class

When an annotation processor generates a static metamodel class for an entity:

- the metamodel class must be annotated with `jakarta.annotation.Generated`,
- each field corresponding to a persistent attribute of an entity must have modifiers `public`, `static`, and either `final` or `volatile`,
- the name of each field, ignoring case, must match the name of an entity attribute, according to the conventions specified below in <<Conventions for Metamodel Fields>>, and with the `_` character in the field name delimiting the attribute names of hierarchical structures or relationships, such as embedded classes.

The fields may be statically initialized, or they may be initialized by the provider during system initialization.

==== Conventions for Metamodel Fields

The following are conventions for static metamodel classes:

- The name of the static metamodel class should consist of underscore (`_`) followed by the entity class name.
- Fields of type `String` should be named with all upper case.
- Fields of type `Attribute` (or a subinterface of `Attribute`) should be named in lower case or mixed case.
- Uninitialized fields should have modifiers `public`, `static`, and `volatile`.
- Initialized fields must have modifiers `public`, `static`, and `final`.
- Fields of type `String` must always be statically initialized, enabling their use in annotation values.

The following subinterfaces of `Attribute` are recommended to obtain the full benefit of the static metamodel:

- `TextAttribute` for entity attributes that represent text, typically of type `String`.
- `ComparableAttribute` for entity attributes that represent other comparable values, such as `long`, `Integer`, `boolean`, `java.time.Instant`, and enumerations.
- `BasicAttribute` for other types of entity attributes, such as collections, embeddables, and other relation attributes.

==== Example Metamodel Class and Usage

Example entity class:

[source,java]
----
@Entity
public class Product {
  public long id;
  public String name;
  public float price;
}
----

Example metamodel class for the entity:

[source,java]
----
@StaticMetamodel(Product.class)
public class _Product {
  public static final String ID = "id";
  public static final String NAME = "name";
  public static final String PRICE = "price";

  public static final ComparableAttribute<Product,Long> id = new ComparableAttributeRecord<>("id");
  public static final TextAttribute<Product> name = new TextAttributeRecord<>("name");
  public static final ComparableAttribute<Product,Float> price = new ComparableAttributeRecord<>("price");
}
----

Example usage:

[source,java]
----
List<Product> found = products.findByNameLike(searchPattern,
                                              _Product.price.desc(),
                                              _Product.name.asc(),
                                              _Product.id.asc());
----
